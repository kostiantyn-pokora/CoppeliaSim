Підручник з інтеграції інтерпретатора мови робота

Цей підручник спробує пояснити, як інтегрувати або вставити інтерпретатор мови робота в CoppeliaSim. Процедура дуже схожа, якщо ви хочете інтегрувати емулятор (наприклад, емулятор конкретного мікроконтролера) у CoppeliaSim. Розширення функціональності CoppeliaSim вимагає більшості часу розробки [плагіна](https://www.coppeliarobotics.com/helpFiles/en/plugins.htm). Переконайтеся, що ви прочитали [підручник про плагіни](https://www.coppeliarobotics.com/helpFiles/en/pluginTutorial.htm) та [підручник про зовнішні контролери](https://www.coppeliarobotics.com/helpFiles/en/externalControllerTutorial.htm), перш ніж продовжити цей посібник.

Файл [сцени](https://www.coppeliarobotics.com/helpFiles/en/scenes.htm) CoppeliaSim, пов’язаний із цим підручником, знаходиться в інсталяційній папці CoppeliaSim scenes\robotLanguageControl.ttt. Ви можете знайти файли проекту плагіна тут, а файли проекту серверної програми [тут](https://github.com/CoppeliaRobotics/mtbServer).

По-перше, почнемо із завантаження відповідного файлу сцени scenes\robotLanguageControl.ttt:

![image](https://user-images.githubusercontent.com/121936602/217095925-4b67c9a2-1404-47d7-9450-c6484db73700.png)

Робот MTB — це уявний робот (MTB означає Machine Type B), який керуватиметься за допомогою уявної мови робота.

Як було сказано раніше, мова робота є уявною та дуже простою. Підтримуються такі команди (одна команда на рядок, введення чутливе до регістру):

```"REM" starts a comment line
"SETLINVEL v": sets the prismatic joint velocity for next movements (v is in m/s)
"SETROTVEL v": sets the revolute joint velocity for next movements (v is in degrees/s)
"MOVE p1 p2 p3 p4": moves to joint positions (p1;p2;p3;p4) (in degrees except for p3 in meters)
"WAIT x": waits x milliseconds
"SETBIT y": sets the bit at position y (1-32) in the robot output port
"CLEARBIT y": clears the bit at position y (1-32) in the robot output port
"IFBITGOTO y label": if bit at position y (1-32) in the robot input port is set, jump to "label"
"IFNBITGOTO y label": if bit at position y (1-32) in the robot input port is not set, jump to "label"
"GOTO label": jumps to "label"
```
Будь-яке слово, відмінне від «REM», «SETLINVEL», «SETTROTVEL», «MOVE», «WAIT», «SETBIT», «CLEARBIT», «IFBITGOTO», «IFNBITGOTO» і «GOTO», вважається міткою. Тепер запустіть симуляцію. Якщо відповідний плагін не знайдено, з’явиться таке повідомлення (відображення повідомлення обробляється [дочірніми сценаріями](https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm), прикріпленими до [об’єктів](https://www.coppeliarobotics.com/helpFiles/en/objects.htm) MTB_Robot і MTB_Robot#0):

![image](https://user-images.githubusercontent.com/121936602/217096147-e84275df-06c2-4727-98fb-e85ea751c27f.png)

Якщо відповідний плагін знайдено, то плагін MTB запустить серверну програму (тобто mtbServer), яка в основному представляє інтерпретатор мови робота та контролер. Немає прямої потреби в серверній програмі, функціональність mtbServer також може працювати безпосередньо в плагіні MTB. Основними перевагами використання цієї функції в серверній програмі є:
- Плагін MTB може діяти як проміжний засіб для будь-якої кількості різних мов, у тому числі тих, які ще не розроблені: плагін MTB просто запустить відповідний сервер залежно від використовуваного робота/мови.
- Якщо мовний інтерпретатор/контролер робота виходить з ладу, CoppeliaSim не вийде з ладу, оскільки це різні та окремі процеси.

В даний час сервер MTB відповідає за два основних завдання:

- отримати код програми (тобто буфер) від плагіна MTB, скомпілювати його та ініціалізувати контролер робота.
- застосовувати вхідні сигнали, проходити програмний код (тривалість кроку може відрізнятися від кроку до кроку) і повертати вихідні сигнали та кути з’єднання.

Якщо MTB-сервер виявить помилку під час компіляції програмного коду, він поверне повідомлення про помилку плагіну, який передасть його викликаючому [дочірньому сценарію](https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm) (тобто в нашому випадку дочірні сценарії, приєднані до об’єктів MTB_Robot і MTB_Robot# 0.), який відображатиме (наприклад):

![image](https://user-images.githubusercontent.com/121936602/217096350-9cf97e45-2d83-4e99-ad5e-89535debc989.png)

Якщо компіляція пройшла успішно, то роботи починають виконувати свою відповідну програму. Симуляція є симуляцією з максимальною швидкістю, але її можна переключити на симуляцію в реальному часі, натиснувши відповідну кнопку панелі інструментів:

![image](https://user-images.githubusercontent.com/121936602/217096400-a3d39f44-8e9a-4f2c-ba81-c9f5f88c833c.png)

Швидкість виконання можна ще більше прискорити, кілька разів натиснувши відповідну кнопку панелі інструментів:

![image](https://user-images.githubusercontent.com/121936602/217096472-7d7ada46-ed2d-4c95-991e-668298a169a7.png)

Кожну програму робота MTB можна окремо призупинити, зупинити або перезапустити в будь-який час за допомогою спеціального діалогового вікна, що відображається, тобто призначеного для [користувача інтерфейсу](https://www.coppeliarobotics.com/helpFiles/en/customUIPlugin.htm):

![image](https://user-images.githubusercontent.com/121936602/217096535-729a948b-ab99-4ee5-91de-f5c17e9f7611.png)

Над спеціальним інтерфейсом є інтерфейс користувача робота MTB, який можна повністю налаштувати. Якщо робота MTB буде скопійовано, його власний інтерфейс також буде скопійовано. Крім можливості контролювати стан виконання програми, спеціальний інтерфейс користувача також відображає поточний рядок програми (команда) і поточні спільні значення MTB. Користувач також може змінювати біти вхідного порту робота та читати біти вихідного порту робота. Вхідні та вихідні порти можуть читатися та відповідно записуватися програмою мови робота. Вхідні та вихідні порти також можна записувати та зчитувати зовнішніми пристроями (наприклад, захватом робота або присоскою) за допомогою відповідних викликів функцій (див. нижче).

До об’єктів MTB_Robot і MTB_Robot#0 прикріплено два дочірніх сценарії. Вони відповідають за обробку спеціальних діалогових вікон і спілкування з плагіном MTB. Більшість коду в дочірніх сценаріях також може оброблятися плагіном. Відкрийте дочірній сценарій, прикріплений до одного з двох MTB-роботів (наприклад, двічі клацнувши піктограму сценарію поруч із моделлю робота в ієрархії сцени). У верхній частині сценарію ви побачите код мови робота.

Спробуйте змінити програму робота MTB, щоб він виконував іншу послідовність рухів. Поекспериментуйте трохи.

Роботи MTB обробляються наступним чином:

- фактична програма мовою робота компілюється та виконується програмою "mtbServer". Ця програма також містить змінні стану робота MTB. Для кожного робота MTB у сцені симуляції буде екземпляр програми mtbServer, запущений плагіном simExtMTB.
- плагін simExtMTB відповідає за надання користувацьких функцій сценарію, а також запускає програму mtbServer, коли це необхідно, і спілкується з нею через сокет.
- дочірні сценарії, додані до MTB_Robot і MTB_Robot#0, перевіряють, чи завантажено плагін simExtMTB, і обробляють зв’язок із плагіном.

Робот MTB і його проста мова робота — це простий прототип, призначений для демонстрації того, як інтегрувати інтерпретатор мови робота в CoppeliaSim. Дуже легко розширити поточну функціональність для набагато складніших роботів або мов роботів. Усе, що потрібно, це:

- Побудова [моделі](https://www.coppeliarobotics.com/helpFiles/en/models.htm) робота. Це включає [імпорт даних CAD](https://www.coppeliarobotics.com/helpFiles/en/importExport.htm), додавання [з’єднань](https://www.coppeliarobotics.com/helpFiles/en/joints.htm) тощо. Цей крок можна повністю виконати в CoppeliaSim.
- Написання [плагіна](https://www.coppeliarobotics.com/helpFiles/en/plugins.htm) для роботи з новим роботом нативно, тобто для роботи з новим роботом шляхом інтерпретації його власної мови робота. Для створення плагіна можна використовувати будь-яку мову, яка має доступ до функцій C-API і яку можна загорнути в dll (але перевага надається c/c++). Інтерпретатор мови робота можна безпосередньо вбудувати в плагін або запустити як зовнішню програму (mtbServer), як це зроблено в цьому посібнику.
- Написання маленького [дочірнього сценарію](https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm), відповідального за обробку [настроюваних діалогів](https://www.coppeliarobotics.com/helpFiles/en/customUIPlugin.htm) і зв’язування робота з плагіном. Цей крок можна повністю виконати в CoppeliaSim.

Тепер давайте подивимося на проект плагіна MTB. Існує одна передумова для вбудовування інтерпретатора мови робота (або іншого емулятора) у CoppeliaSim:

- Інтерпретатор мови робота повинен мати можливість виконуватися кілька разів паралельно. Це означає, що необхідно підтримувати кілька екземплярів інтерпретатора, щоб підтримувати кілька ідентичних паралельно працюючих роботів. Це можна вирішити найпростіше, запустивши новий інтерпретатор для кожного нового робота, як це зроблено в цьому посібнику.

Під час написання будь-якого плагіна переконайтеся, що плагін отримує доступ до [звичайного API](https://www.coppeliarobotics.com/helpFiles/en/apiFunctions.htm) CoppeliaSim лише з основного потоку (або з потоку, створеного CoppeliaSim)! Плагін може запускати нові потоки, але в такому випадку ці нові потоки не слід використовувати для доступу до CoppeliaSim (однак вони можуть використовуватися для зв’язку із серверною програмою, для зв’язку з деяким обладнанням, для виконання фонових обчислень тощо).

Тепер давайте подивимося на дочірній скрипт, який приєднаний до робота MTB. Код може здатися досить довгим або складним. Однак більшість функціональних можливостей, оброблених у дочірньому сценарії, також можуть бути безпосередньо оброблені в плагіні, що робить дочірній сценарій набагато меншим/чистішим. Перевага роботи з більшістю функціональних можливостей у дочірньому сценарії полягає в тому, що зміни можна виконувати без необхідності перекомпілювати плагін!

Нижче наведено основні функції дочірнього сценарію робота MTB:

- Перевірка чи завантажено плагін. Якщо ні, виводиться повідомлення про помилку.
- Спілкування з плагіном. Це означає, що інформація надсилається та отримується від плагіна MTB із функціями спеціального сценарію.
- Застосування щойно обчислених спільних значень до моделі робота MTB. Це також можна вирішити у плагіні MTB.
- Реагування на події в настроюваних діалогах, як-от натискання кнопок.
- Оновлення стану настроюваних діалогів.

Наступні 3 користувальницькі функції сценарію представляють головний інтерес (інші експортуються плагіном):


```
int mtbServerHandle,string message=simMTB.startServer(string mtbServerExecutable, 
int portNumber,charBuffer program,table[4] jointPositions, table[2] velocities)
```
```
int result,string message=simMTB.step(int mtbServerHandle,float timeStep)
```
```
table[4] jointValues=simMTB.getJoints(int mtbServerHandle)
```

- simMTB.startServer: запускає серверну програму (наприклад, mtbServer) на вказаному порту, підключається до нього та надсилає код мови робота, початкові лінійні/кутові позиції з’єднань і початкові швидкості. Натомість функція повертає дескриптор сервера (якщо успішно) і повідомлення (зазвичай повідомлення про помилку компіляції).
- simMTB.step: проходить через програму на мові робота з указаним timeStep і повертає значення результату та повідомлення (зазвичай код, який зараз виконується).
- simMTB.getJoints: отримує поточні лінійні/кутові позиції з’єднань. Позиції лінійних/кутових з’єднань автоматично оновлюються під час виклику simMTB.step.

Ви також можете уявити трохи модифікувати функцію step і додати одну додаткову функцію, щоб мати можливість обробляти проміжні події, викликані виконанням програми на мові робота. У цьому випадку на кожному етапі моделювання потрібно буде виконати наступний код сценарію (у дочірньому сценарії):

```
local dt=sim.getSimulationTimeStep()
while (dt>0) do
    result,dt,cmdMessage=simMTB.step(mtbServerHandle,dt) -- where the returned dt is the remaining dt
    local event=simMTB.getEvent()
    while event~=-1 do
        -- handle events here
        event=simMTB.getEvent()
    end
end
```



