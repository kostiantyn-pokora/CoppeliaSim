# Навчальний посібник BubbleRob #
Цей посібник допоможе ознайомитись з усіма функціями CoppeliaSim під час розробки простого мобільного робота *BubbleRob*. Файл сцени CoppeliaSim, пов’язаний із цим матеріалом, знаходиться в *scenes/tutorials/BubbleRob*. Наступний малюнок ілюструє сцену моделювання, яку ми розробимо:

![bubbleRobTut1](bubbleRobTut1.jpg)

Оскільки цей посібник охоплюватиме багато різних аспектів, не забудьте також переглянути інші, головним чином про створення імітаційної моделі. Перш за все, заново запустіть CoppeliaSim. Симулятор відображає стандартну сцену. Ми почнемо з тіла *BubbleRob*.

Ми додаємо примітивну сферу діаметром 0,2 до сцени за допомогою [Рядок меню --> Додати --> Примітивна форма --> Сфера]. Налаштовуємо елемент **X-size** на 0,2, потім натискаємо **OK**. Створена сфера з’явиться на шарі видимості 1 за замовчуванням і буде динамічною та відповідальною (оскільки ми залишили ввімкненим пункт **Створити динамічну та чуйну форму**). Це означає, що тіло *BubbleRob* буде падати та зможе реагувати на зіткнення з іншими відповідними формами (тобто змодельованими фізичним механізмом). Ми бачимо, що це властивості динаміки форми: увімкнено елементи **Body is respondable** і **Body is dynamic**. Ми починаємо симуляцію (за допомогою кнопки на панелі інструментів або натисканням <control-space> у вікні сцени) і копіюємо та вставляємо створену сферу (за допомогою [Панель меню --> Редагувати --> Копіювати вибрані об’єкти], а потім [Рядок меню --> Редагувати -> Вставити буфер] або за допомогою <control-c>, потім <control-v>): дві сфери реагуватимуть на зіткнення та відкотяться. Ми зупиняємо симуляцію: дубльована сфера буде автоматично видалена. Цю типову поведінку можна змінити в діалоговому вікні симуляції.
 
Ми також хочемо, щоб тіло *BubbleRob* можна було використовувати іншими модулями обчислення (наприклад, обчислення відстані). З цієї причини ми вмикаємо зіткнення, вимірювання та виявлення у загальних властивостях об’єкта для цієї форми, якщо вони ще не ввімкнені. Тепер за бажанням ми могли б змінити візуальний вигляд нашої сфери у властивостях форми.

Тепер ми відкриваємо діалогове вікно позиції на вкладці **переміщення**, вибираємо сферу, що представляє тіло *BubbleRob*, і вводимо 0,02 для **Along Z**. Переконаємося, що **Relative to**-item встановлено на **World**. Потім ми натискаємо **Перемістити виділення**. Це переміщує всі вибрані об’єкти на 2 см уздовж абсолютної осі Z і фактично трохи підняло нашу сферу. В ієрархії сцени ми двічі клацаємо псевдонім сфери, щоб мати змогу редагувати його. Вводимо *bubbleRob* і натискаємо enter.

Далі ми додаємо датчик наближення, щоб *BubbleRob* знав, коли він наближається до перешкод: ми вибираємо [Рядок меню --> Додати --> Датчик наближення --> Тип конуса]. У діалоговому вікні орієнтації на вкладці **Орієнтація** ми вводимо 90 для **Навколо Y** і **Навколо Z**, а потім натискаємо **Повернути виділення**. У діалоговому вікні позиції на вкладці позиції ми вводимо 0,1 для **X-coord**. і 0,12 для **Z-коорд**. Датчик наближення тепер правильно розташований відносно тіла *BubbleRob*. Ми двічі клацаємо піктограму датчика наближення в ієрархії сцени, щоб відкрити діалогове вікно властивостей. Ми натискаємо **Показати параметр об'єму**, щоб відкрити діалогове вікно об'єму датчика наближення. Ми регулюємо елементи **Offset** на 0,005, **Angle** на 30 і **Range** на 0,15. Потім у властивостях датчика наближення натискаємо **Показати параметри виявлення**. Відкриється діалогове вікно параметрів виявлення датчика наближення. Ми знімаємо позначку з пункту **Не дозволяти виявлення якщо відстань менша ніж** а потім знову закриваємо це діалогове вікно. В ієрархії сцен ми двічі клацаємо псевдонім датчика наближення, щоб відредагувати його. Вводимо *sensingNose* і натискаємо enter.

Ми вибираємо *sensingNose*, потім control-select *bubbleRob*, потім клацаємо [Рядок меню --> Редагувати --> Зробити останній вибраний об’єкт батьківським]. Це кріпить датчик до тіла робота. Ми також могли б перетягнути *sensingNose* на *bubbleRob* в ієрархії сцени. Ось що ми зараз маємо:

 ![bubbleRobTut2](bubbleRobTut2.jpg)
 
 [Датчик наближення, прикріплений до тіла bubbleRob]

Далі ми подбаємо про колеса *BubbleRob*. Ми створюємо нову сцену за допомогою [Рядок меню --> Файл --> Нова сцена]. Часто дуже зручно працювати з кількома сценами, щоб візуалізувати та працювати лише над окремими елементами. Додаємо примітивний циліндр з розмірами (0,08,0,08,0,02). Що стосується тіла *BubbleRob*, ми вмикаємо зіткнення, вимірювання та виявлення у загальних властивостях об’єкта для цього циліндра, якщо вони ще не ввімкнені. Потім ми встановлюємо абсолютну позицію циліндра (0,05,0,1,0,04), а його абсолютну орієнтацію (-90,0,0). Ми змінюємо псевдонім на *leftWheel*. Ми копіюємо та вставляємо колесо та встановлюємо абсолютну координату Y копії на -0,1. Перейменовуємо копію на *rightWheel*. Ми вибираємо два колеса, копіюємо їх, потім повертаємося до сцени 1 і вставляємо колеса.

Тепер нам потрібно додати шарніри (або двигуни) для коліс. Ми клацаємо [Рядок меню --> Додати --> З’єднання --> Поворот], щоб додати поворотне з’єднання до сцени. У більшості випадків, коли до сцени додається новий об’єкт, цей об’єкт з’являтиметься біля початку світу. Ми зберігаємо з’єднання вибраним, потім натискаємо клавішу Control і вибираємо *leftWheel*. У діалоговому вікні «Позиція» на вкладці **Позиція** ми натискаємо кнопку **Застосувати до вибору**: це розташовує з’єднання в центрі лівого колеса. Потім у діалоговому вікні орієнтації на вкладці **Орієнтація** ми робимо те саме: це орієнтує з’єднання так само, як і ліве колесо. Ми змінюємо назву суглоба на leftMotor. Тепер ми двічі клацаємо піктограму з’єднання в ієрархії сцени, щоб відкрити діалогове вікно властивостей з’єднання. Потім ми натискаємо **Показати динамічні параметри**, щоб відкрити діалогове вікно властивостей динаміки суглоба. Ми **вмикаємо двигун** і ставимо галочку біля пункту **Lock motor when target velocity нуль**. Тепер ми повторюємо ту саму процедуру для правого двигуна та перейменуємо його на *rightMotor*. Тепер ми прикріплюємо ліве колесо до лівого двигуна, праве колесо до правого двигуна, потім приєднуємо два двигуни до *bubbleRob*. Ось що ми маємо:
