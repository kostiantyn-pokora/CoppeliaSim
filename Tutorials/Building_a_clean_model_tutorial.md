# Посібник зі створення чистої моделі #
Цей навчальний посібник допоможе вам крок за кроком створити чисту імітаційну модель робота чи будь-якого іншого предмета. Це дуже важлива тема, можливо, найважливіший аспект, щоб мати приємну на вигляд, швидку відображення, швидку симуляцію та стабільну імітаційну модель.
Щоб проілюструвати процес створення моделі, ми створимо наступний маніпулятор:

![modelTut1](modelTut1.jpg)

[Модель робота-маніпулятора]

## Побудова видимих фігур ##
Створюючи нову модель, спочатку ми обробляємо лише її візуальний аспект: динамічний аспект (його ще більш спрощена/оптимізована модель), з’єднання, датчики тощо буде розглянуто пізніше.

Тепер ми могли безпосередньо створювати примітивні форми в CoppeliaSim за допомогою [Рядок меню --> Додати --> Примітивна форма --> ...]. Роблячи це, ми маємо можливість створювати [примітивні форми, або правильні форми](https://www.coppeliarobotics.com/helpFiles/en/shapes.htm). Примітивні фігури будуть оптимізовані для динамічної взаємодії, а також будуть безпосередньо активовані динамічно (тобто падіння, зіткнення, але це можна вимкнути на пізнішому етапі). Примітивні форми будуть простими сітками, які можуть містити недостатньо деталей або геометричної точності для нашого застосування. Іншим нашим варіантом у такому випадку буде імпорт сітки із зовнішньої програми.

Під час імпорту даних САПР із зовнішньої програми найважливішим є переконатися, що модель САПР не надто важка, тобто не містить занадто багато трикутників. Ця вимога важлива, оскільки важка модель буде повільно відображатися, а також уповільнити роботу різних модулів обчислень, які можуть бути використані на пізнішому етапі (наприклад, [обчислення мінімальної відстані](https://www.coppeliarobotics.com/helpFiles/en/distanceCalculation.htm) або [динаміки](https://www.coppeliarobotics.com/helpFiles/en/dynamicsModule.htm)). Наступний приклад зазвичай не підходить (навіть якщо, як ми побачимо пізніше, є засоби для спрощення даних у CoppeliaSim):

![modelTut2](modelTut2.jpg)

[Складні дані САПР (у твердому та каркасному)]

Наведені вище дані CAD дуже важкі: вони містять багато трикутників (понад 47 000), що було б добре, якби ми використали лише один екземпляр у порожній сцені. Але здебільшого вам захочеться змоделювати кілька екземплярів одного робота, прикріпити різні типи захватів і, можливо, запропонувати цим роботам взаємодіяти з іншими роботами, пристроями чи середовищем. У такому випадку сцена симуляції може швидко стати надто повільною. Як правило, ми рекомендуємо моделювати робота з не більше ніж 20 000 трикутниками, але в більшості випадків 5 000-10 000 трикутників також підійдуть. Пам’ятайте: менше – краще майже в усіх аспектах.
Що робить цю модель такою важкою? По-перше, моделі, які містять отвори та дрібні деталі, потребуватимуть набагато більше трикутних граней для правильного зображення. Тому, якщо це можливо, спробуйте видалити всі отвори, гвинти, внутрішню частину об’єктів тощо з вихідних даних моделі. Якщо у вас є вихідні дані моделі, представлені у вигляді параметричних поверхонь/об’єктів, у більшості випадків досить просто вибрати елементи та видалити їх (наприклад, у Solidworks). Другим важливим кроком є експорт вихідних даних з обмеженою точністю: більшість програм САПР дозволяють вказати рівень деталей експортованих сіток. Також може бути важливо експортувати об’єкти в кілька кроків, коли малюнок складається з великих і малих об’єктів; це робиться для того, щоб уникнути надто точного визначення великих об’єктів (забагато трикутників) і надто грубого визначення малих об’єктів (замало трикутників): просто спочатку експортуйте великі об’єкти (налаштувавши потрібні параметри точності), а потім малі об’єкти (налаштувавши налаштування точності) ).

Тепер припустимо, що ми застосували всі можливі спрощення, як описано в попередньому розділі. Ми все ще можемо отримати занадто важку сітку після імпорту:

![modelTut3](modelTut3.jpg)

[Імпортовані дані CAD]

Ви можете помітити, що весь робот був імпортований як одна сітка. Пізніше ми побачимо, як це правильно розділити. Зверніть також увагу на неправильну орієнтацію імпортованої сітки: найкраще залишити орієнтацію такою, як вона є, доки не буде побудовано всю модель, оскільки, якщо на пізнішому етапі ми захочемо імпортувати інші елементи, пов’язані з тим самим роботом, вони будуть автоматично маюти правильне положення/орієнтацію відносно вихідної сітки.
На цьому етапі ми маємо в своєму розпорядженні кілька функцій для спрощення сітки:

- Автоматичне поділ сітки: дозволяє генерувати нову форму для всіх елементів, які не з’єднані між собою спільним краєм. Це не завжди працює для вибраної сітки, але завжди варто спробувати, оскільки робота над елементами сітки дає нам більше контролю, ніж якби ми мали працювати над усіма елементами одночасно. Доступ до цієї функції можна отримати за допомогою [Menu bar --> Edit --> Grouping/Merging --> Divide selected shapes]. Іноді сітка буде розділена більше, ніж очікувалося. У такому випадку просто об’єднайте елементи, які логічно належать разом (тобто матимуть однакові візуальні атрибути та є частиною одного посилання), назад в одну форму ([Menu bar --> Edit -> Grouping/Merging --> Merge selected shapes]).

- Вилучити опуклу оболонку: дозволяє спростити сітку, перетворивши її на опуклу оболонку. Доступ до цієї функції можна отримати за допомогою [Menu bar --> Edit --> Morph selection into convex shapes].

- Знищити сітку: дозволяє зменшити кількість трикутників у сітці. Доступ до цієї функції можна отримати за допомогою [Menu bar --> Edit --> Decimate selected shape...].
Немає заздалегідь визначеного порядку, у якому вищезгадані функції можуть/потрібно застосовуватися (за винятком першого елемента у списку, який завжди слід пробувати першим), це сильно залежить від геометрії сітки, яку ми намагаємося спростити. Наступне зображення ілюструє наведені вище функції, застосовані до імпортованої сітки (припустімо, що перший елемент у списку не спрацював для нас):

![image](image.png)

[Опукла оболонка та розрізана сітка]

Зверніть увагу, що опукла оболонка не допомагає нам на цьому етапі. Ми вирішуємо спочатку використати функцію децимації сітки, а потім запускаємо функцію двічі, щоб розділити кількість трикутників на загальну суму 50. У підсумку ми отримуємо сітку, яка містить 2660 трикутників (оригінальна імпортована сітка містила понад 136 000 трикутників!). Кількість трикутників/вершин фігури можна побачити в [діалоговому вікні геометрії фігури](https://www.coppeliarobotics.com/helpFiles/en/geometryDialog.htm). 2660 трикутників — це надзвичайно мало трикутників для цілої моделі робота, і від цього візуальний вигляд може трохи постраждати.
На цьому етапі ми можемо почати розділяти робота на окремі ланки (пам’ятайте, що зараз у нас є лише одна форма для всього робота). Це можна зробити двома способами:
- Автоматичне поділ сітки: ця функція, яка вже була описана в попередньому розділі, перевірить форму та створить нову форму для всіх елементів, які не з’єднані між собою спільним краєм. Це не завжди працює, але завжди варто спробувати. Доступ до цієї функції можна отримати за допомогою [Рядок меню --> Редагувати --> Групування/об’єднання --> Розділити вибрані фігури].
- Поділ сітки вручну: за допомогою [режиму редагування трикутника](https://www.coppeliarobotics.com/helpFiles/en/triangleEditMode.htm) ви можете вручну вибрати трикутники, які логічно належать разом, а потім натиснути «Витягнути форму». Це створить нову форму сцени. Видаліть вибрані трикутники після цієї операції.

У випадку нашої сітки метод 1 спрацював нормально:

![modelTut5](modelTut5.jpg)

[Розділена сітка]

Тепер ми можемо ще більше вдосконалити/спростити окремі форми. Іноді також форма може виглядати краще, якщо замість неї використовувати її опуклу оболонку. В інших випадках, щоб отримати бажаний результат, вам доведеться повторно використовувати кілька описаних вище прийомів. Візьмемо, наприклад, наступну сітку:

![modelTut6](modelTut6.jpg)

[Імпортована сітка]

Проблема з наведеною вище формою полягає в тому, що ми не можемо її красиво спростити через отвори, які вона містить. Тож нам доведеться піти складнішим шляхом через [режим редагування форми](https://www.coppeliarobotics.com/helpFiles/en/shapeEditModes.htm), де ми можемо витягувати окремі елементи, які логічно належать до тієї самої опуклої суб-сутності. Цей процес може тривати кілька ітерацій: спочатку ми виділяємо 3 приблизних опуклих елемента. Наразі ми ігноруємо трикутники, які є частиною двох отворів. Під час редагування форми в режимі редагування форми може бути зручно перемикати [шари видимості](https://www.coppeliarobotics.com/helpFiles/en/layerSelectionDialog.htm), щоб побачити, що закрито іншими елементами сцени.

![modelTut7](modelTut7.jpg)

[Крок 1]

У підсумку ми маємо інструмент із трьох форм, але дві з них потребують подальшого вдосконалення. Тепер ми можемо стерти трикутники, які є частиною отворів. Нарешті, ми витягуємо опуклу оболонку окремо для 3 фігур, а потім об’єднуємо їх разом за допомогою [Menu bar --> Edit --> Grouping/Merging --> merge selected shapes]:![modelTut8](https://user-images.githubusercontent.com/121936602/217019549-72987bd1-8db5-4fb9-841b-d5fd67e862ba.jpg)

[Крок 2]

У CoppeliaSim ми можемо вказати кут затінення, який визначає, наскільки фасетками буде відображатися форма. Цей параметр і деякі інші, наприклад колір форми, можна налаштувати у [властивостях форми](https://www.coppeliarobotics.com/helpFiles/en/simulationPropertiesDialog.htm). Пам’ятайте, що [форми бувають на різний смак](https://www.coppeliarobotics.com/helpFiles/en/shapes.htm). У цьому підручнику ми досі мали справу лише з простими фігурами: проста фігура має один набір візуальних атрибутів (тобто один колір, один кут затінення тощо). Якщо об’єднати дві фігури, результатом буде проста фігура. Ви також можете групувати фігури, у цьому випадку кожна фігура збереже свої візуальні атрибути.

На наступному кроці ми можемо об’єднати елементи, які логічно належать один одному (якщо вони є частиною одного жорсткого елемента та мають однакові візуальні атрибути). Потім ми змінюємо візуальні атрибути різних елементів. Найпростіше налаштувати кілька фігур, які мають різні кольори та візуальні атрибути, і якщо ми називаємо колір певним рядком, ми можемо пізніше легко програмно змінити цей колір, навіть якщо фігура є частиною складеної фігури. Потім ми вибираємо всі фігури з однаковими візуальними атрибутами, потім вибираємо форму, яка вже була скоригована, і натискаємо «Застосувати до виділення» один раз для кольорів, один раз для інших властивостей у [властивостях фігури](https://www.coppeliarobotics.com/helpFiles/en/shapeProperties.htm): це переносить усі візуальні атрибути вибраних форм (включаючи назву кольору, якщо ви її вказали). У підсумку ми маємо 17 окремих форм:

![image](https://user-images.githubusercontent.com/121936602/217020242-ddc15f01-625d-4833-907a-dc0b27e253a9.png)

[Скориговані візуальні атрибути]

Тепер ми можемо групувати фігури, які є частиною одного посилання, за допомогою [Menu bar --> Edit --> Grouping/merging -> Group selected shapes]. У підсумку ми маємо 7 фігур: основу робота (або основу ієрархічного дерева робота) і 6 мобільних посилань. Також важливо правильно називати об’єкти: ви робите це подвійним клацанням на псевдонімі об’єкта в [ієрархії сцени](https://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#SceneHierarchy). За замовчуванням фігури буде призначено шару видимості 1, але їх можна змінити в [загальних властивостях об’єкта](https://www.coppeliarobotics.com/helpFiles/en/commonPropertiesDialog.htm). За замовчуванням для сцени активовано лише [шари видимості 1-8](https://www.coppeliarobotics.com/helpFiles/en/layerSelectionDialog.htm). Зараз ми маємо наступне:

![image](https://user-images.githubusercontent.com/121936602/217020689-6ccdd70c-7a8e-4008-8682-ccba587c953c.png)

[Окремі елементи складають робота]

Коли фігура створюється або змінюється, CoppeliaSim автоматично встановлює положення та орієнтацію опорної рамки. Рамка відліку фігури завжди буде розташована в геометричному центрі фігури. Орієнтація рамки буде вибрана так, щоб обмежувальна рамка фігури залишалася якомога меншою. Це не завжди виглядає красиво, але ми завжди можемо змінити орієнтацію системи відліку форми в будь-який час. Тепер ми змінюємо орієнтацію систем відліку всіх наших створених форм за допомогою [Menu bar --> Edit --> Reorient bounding box --> with reference frame of world]. У [діалоговому вікні геометрії фігури](https://www.coppeliarobotics.com/helpFiles/en/geometryDialog.htm) є більше можливостей для зміни орієнтації опорної рамки.

## Нарощування стиків ##

Тепер ми подбаємо про стикі/мотори. У більшості випадків ми знаємо точне положення та орієнтацію кожного з стику. У такому випадку ми просто додаємо з’єднання за допомогою [Menu bar --> Add --> Joints --> ...], а потім ми можемо змінити їхнє положення та орієнтацію за допомогою [діалогового вікна розташування](https://www.coppeliarobotics.com/helpFiles/en/positionDialog.htm) та [орієнтації](https://www.coppeliarobotics.com/helpFiles/en/orientationDialog.htm). В інших ситуаціях ми маємо лише параметри Денавіта-Хартенберга (тобто D-H). У такому випадку ми можемо побудувати наші з’єднання за допомогою моделі інструменту, розташованої в Models/tools/Denavit-Hartenberg joint creator.ttm у браузері моделей. В інших випадках ми не маємо інформації про розташування та орієнтацію спільних частин. Потім нам потрібно витягти їх з імпортованої сітки. Припустимо, це наш випадок. Замість того, щоб працювати над зміненою, більш наближеною сіткою, ми відкриваємо нову сцену та знову імпортуємо оригінальні дані CAD. У більшості випадків ми можемо витягти сітки або примітивні форми з оригінальної сітки. Перший крок — розділити оригінальну сітку. Якщо це не працює, ми робимо це через [режим редагування трикутника](https://www.coppeliarobotics.com/helpFiles/en/triangleEditMode.htm). Припустімо, що ми можемо розділити оригінальну сітку. Зараз у нас є менші об’єкти, які ми можемо оглянути. Ми шукаємо обертові форми, які можна було б використовувати як еталон для створення з’єднань у їхніх місцях з однаковою орієнтацією. Спочатку приберіть усі непотрібні предмети. Іноді також корисно працювати з декількома відкритими сценами для легшої візуалізації/маніпуляції. У нашому випадку ми спершу зосереджуємося на основі робота: вона містить циліндр, який має правильне положення для першого стика. У режимі редагування трикутника ми маємо:
 
![image](https://user-images.githubusercontent.com/121936602/217021798-d9c7ad50-d95f-4e55-a5a1-6e4f3b592efc.png)

[База робота: візуалізація нормального та трикутного режимів редагування]

Змінюємо вид камери за допомогою [кнопки панелі інструментів](https://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#toolbars) [вибору сторінок](https://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#toolbars), щоб дивитися на об’єкт збоку. [Кнопка на панелі інструментів, яка підходить для перегляду](https://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#toolbars), може стати в нагоді, щоб правильно обрамити об’єкт у редакції. Потім переходимо в [режим редагування вершин](https://www.coppeliarobotics.com/helpFiles/en/vertexEditMode.htm) і виділяємо всі вершини, які належать верхньому диску. Пам’ятайте, що вмикаючи/вимикаючи деякі [шари](https://www.coppeliarobotics.com/helpFiles/en/layerSelectionDialog.htm), ми можемо приховати інші об’єкти на сцені. Потім повертаємося в режим редагування трикутника:

![image](https://user-images.githubusercontent.com/121936602/217022003-1ae746f6-5893-4442-95d1-9e067db688ba.png)

[Вибраний верхній диск, режим редагування вершин (1 і 2), режим редагування трикутника (3)]

Тепер ми клацаємо «Extract cylinder» (у цьому випадку також буде працювати), це створило форму циліндра на сцені на основі вибраних трикутників. Виходимо з режиму редагування і скидаємо зміни. Тепер ми додаємо поворотне з’єднання за допомогою [Menu bar --> Add --> Joint --> Revolute], залишаємо його вибраним, а потім натискаємо клавішу Control і вибираємо вилучену форму циліндра. У [діалоговому вікні «Позиція»](https://www.coppeliarobotics.com/helpFiles/en/positionDialog.htm) на вкладці «Позиція» ми клацаємо «Застосувати до вибору»: це фактично копіює положення циліндра x/y/z на з’єднання. Тепер обидві позиції ідентичні. У діалоговому вікні орієнтації на вкладці орієнтації ми також натискаємо «Застосувати до виділення»: орієнтація вибраних об’єктів тепер також однакова. Іноді нам потрібно буде додатково повернути стика приблизно на 90/180 градусів навколо його власної системи відліку, щоб отримати правильну орієнтацію або напрямок обертання. За потреби ми можемо зробити це на вкладці обертання цього діалогового вікна (у такому випадку не забудьте натиснути кнопку «Власний кадр»). Подібним чином ми могли б також зміщувати стик уздовж його осі або навіть робити більш складні операції. Ось що ми маємо:

![image](https://user-images.githubusercontent.com/121936602/217022723-9b146919-6b17-4af6-ae8e-6f8c0d3f7d69.png)

[З’єднання в правильному місці, з правильною орієнтацією]

Тепер ми копіюємо з’єднання назад у нашу оригінальну сцену та зберігаємо його (не забувайте регулярно зберігати свою роботу! Функція скасування/повторення корисна, але не захищає вас від інших невдач). Ми повторюємо описану вище процедуру для всіх стикків нашого робота, а потім перейменуємо їх. Ми також робимо всі з’єднання трохи довшими у [властивостях з’єднань](https://www.coppeliarobotics.com/helpFiles/en/jointProperties.htm), щоб побачити їх усі. За замовчуванням з’єднання буде призначено шару видимості 2, але їх можна змінити в [загальних властивостях об’єкта](https://www.coppeliarobotics.com/helpFiles/en/commonPropertiesDialog.htm). Тепер ми призначаємо всі з’єднання шару видимості 10, а потім тимчасово вмикаємо [шар видимості 10 для сцени](https://www.coppeliarobotics.com/helpFiles/en/layerSelectionDialog.htm), щоб також візуалізувати ці з’єднання (за замовчуванням для сцени активовано лише шари видимості 1-8). Ось що ми маємо:

![image](https://user-images.githubusercontent.com/121936602/217022947-3470164b-1865-4f73-afd3-b061a7c8da0c.png)

[Стики в правильній конфігурації]

На цьому етапі ми можемо почати будувати ієрархію моделі та завершити визначення моделі. Але якщо ми хочемо, щоб наш робот був [динамічно ввімкнений](https://www.coppeliarobotics.com/helpFiles/en/designingDynamicSimulations.htm), то є додатковий проміжний крок:

##Побудова динамічних фігур##

Якщо ми хочемо, щоб наш робот був [динамічно активним](https://www.coppeliarobotics.com/helpFiles/en/designingDynamicSimulations.htm), тобто реагував на зіткнення, падіння тощо, тоді нам потрібно створити/налаштувати форми належним чином: фігура може бути:
- Динамічна або статична: динамічна (або нестатична) форма впаде і зазнає впливу зовнішніх сил/моментів. З іншого боку, статична (або нединамічна) фігура залишатиметься на місці або буде слідувати за рухом свого батька в ієрархії сцени.
- Відповідна чи невідповідна: відповідна форма викличе реакцію зіткнення з іншими відповідними формами. На них (та/або) на їхній колайдер впливатиме їхній рух, якщо вони динамічні. З іншого боку, фігури, які не відповідають, не обчислять відповідь на зіткнення, якщо вони зіткнуться з іншими фігурами.

[Тут](https://www.coppeliarobotics.com/helpFiles/en/designingDynamicSimulations.htm#staticAndRespondable) проілюстровано два пункти. Відповідальні форми мають бути максимально простими, щоб забезпечити швидку та стабільну симуляцію. Фізичний движок зможе симулювати наступні 5 типів фігур з різним ступенем швидкості та стабільності:

- [Примітивні форми](https://www.coppeliarobotics.com/helpFiles/en/designingDynamicSimulations.htm#pureShapes): примітивна форма буде стабільною та дуже ефективно оброблятиметься фізичним механізмом. Недоліком є те, що примітивні форми обмежені в геометрії: переважно кубоїди, циліндри, сфери та капсули. Якщо можливо, використовуйте їх для предметів, які контактують з іншими предметами протягом тривалого часу (наприклад, ноги робота-гуманоїда, ---основа серійного маніпулятора, захвату тощо). Примітивні форми можна створити за допомогою [Menu bar --> Add --> Primitive shape].
- [Примітивні складені форми](https://www.coppeliarobotics.com/helpFiles/en/designingDynamicSimulations.htm#pureShapes): примітивна складена форма — це група кількох примітивних форм.Він працює так само добре, як і примітивні форми, і має схожі властивості. Примітивні складені фігури можна створити шляхом групування кількох примітивних фігур [Menu bar --> Edit --> Grouping/Merging --> Group selected shapes].
- [Опуклі форми](https://www.coppeliarobotics.com/helpFiles/en/designingDynamicSimulations.htm#convexShapes): опукла форма буде трохи менш стабільною та займе трохи більше часу на обчислення, коли її оброблятиме фізичний механізм. Він допускає більш загальну геометрію (єдина вимога: він повинен бути опуклим), ніж примітивні форми. Якщо можливо, використовуйте опуклі форми для предметів, які спорадично контактують з іншими предметами (наприклад, різні ланки робота). Опуклі фігури можна створити за допомогою [Menu bar --> Add --> Convex hull of selection] або [Menu bar --> Edit --> Morph selection into convex shapes].
- [Складені опуклі форми або опуклі розкладені фігури](https://www.coppeliarobotics.com/helpFiles/en/designingDynamicSimulations.htm#convexShapes): опукла розкладена фігура — це група кількох опуклих фігур. Він виконує так само добре, як і опуклі форми, і має подібні властивості. Опуклі розкладені фігури можна створити шляхом групування кількох опуклих фігур [Menu bar --> Edit --> Grouping/Merging --> Group selected shapes] за допомогою [Menu bar --> Add --> Convex decomposition of selection...] або за допомогою [Menu bar --> Edit --> Morph selection into its convex decomposition...].
- Випадкові форми: випадкова форма – це форма, яка не є опуклою чи примітивною. Зазвичай він має низьку продуктивність (швидкість і стабільність обчислень). Наскільки це можливо, уникайте використання випадкових форм.

Отже, порядок переваги буде таким: примітивні форми, опуклі форми та випадкові форми. Обов’язково також прочитайте [цю сторінку](https://www.coppeliarobotics.com/helpFiles/en/shapes.htm).У випадку робота, якого ми хочемо побудувати, ми зробимо основу робота у вигляді примітивного циліндра, а інші ланки — опуклі або опуклі декомпозиційні форми.

Ми могли б використовувати динамічні форми також як видимі частини робота, але це, ймовірно, виглядало б недостатньо добре. Тож натомість для кожної видимої форми, яку ми створили в [першій частині підручника](https://www.coppeliarobotics.com/helpFiles/en/buildingAModelTutorial.htm#visibleShapes), ми створимо динамічно ввімкнутий відповідник, який залишимо прихованим: прихована частина представлятиме динамічну модель і використовуватиметься виключно фізичним механізмом, тоді як видима частина використовуватиметься для візуалізації, а також для [обчислення мінімальної відстані](https://www.coppeliarobotics.com/helpFiles/en/distanceCalculation.htm), [виявлення датчика наближення](https://www.coppeliarobotics.com/helpFiles/en/proximitySensors.htm) тощо.

Ми вибираємо робота-об’єкта, копіюємо та вставляємо його в нову сцену (щоб зберегти вихідну модель недоторканою) і запускаємо [режим редагування трикутника](https://www.coppeliarobotics.com/helpFiles/en/triangleEditMode.htm). Якби об’єкт-робот був складеною формою, нам спочатку потрібно було б розгрупувати його ([Menu bar --> Edit --> Grouping/Merging --> Ungroup selected shapes]), а потім об’єднати окремі фігури ([Menu bar --> Edit --> Grouping/Merging --> Merge selected shapes]), перш ніж запустити режим редагування трикутника. Тепер вибираємо кілька трикутників, які символізують кабель живлення, і стираємо їх. Потім ми вибираємо всі трикутники цієї форми та натискаємо «Витягнути циліндр». Тепер ми можемо вийти з режиму редагування, і наш базовий об’єкт представлено у вигляді примітивного циліндра:

![image](https://user-images.githubusercontent.com/121936602/217025000-3de692ed-a2d9-4db2-9ad4-65a215f410cd.png)

[Примітивна процедура генерації циліндра, в режимі редагування трикутника]

Ми перейменуємо нову фігуру (подвійним клацанням на її псевдонімі в [ієрархії сцени](https://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#SceneHierarchy)) на robot_dyn, призначимо її до шару видимості 9, а потім скопіюємо її на вихідну сцену. Решта зв’язків буде змодельовано як опуклі форми або складені опуклі форми. Тепер ми вибираємо перше мобільне посилання (тобто об’єкт robot_link1) і створюємо з нього опуклу форму за допомогою [Menu bar --> Add --> Convex hull of selection]. Ми перейменуємо його на robot_link_dyn1 і призначимо шару видимості 9. Якщо вилучення опуклої оболонки не зберігає достатньо деталей оригінальної форми, тоді ви все одно можете вручну витягти кілька опуклих оболонок із складових елементів, а потім згрупувати всі опуклі оболонки за допомогою [Menu bar --> Edit --> Grouping/Merging --> Group selected shapes]. Якщо це здається проблематичним або забирає багато часу, ви можете автоматично витягнути опуклу розкладену фігуру за допомогою [Menu bar --> Add --> Convex decomposition of selection...]:

![image](https://user-images.githubusercontent.com/121936602/217025409-15475ad9-c2b1-4ed7-b3bc-89ed15053ecf.png)

[Оригінальна форма та кулон опуклої форми]

![image](https://user-images.githubusercontent.com/121936602/217025513-97b66d98-e3f2-44b8-9dda-27a74da9a147.png)

[Оригінальна форма та кулон із опуклою розкладеною формою]

Тепер ми повторюємо ту саму процедуру для всіх решти посилань робота. Коли це буде зроблено, ми прикріплюємо кожну видиму фігуру до відповідної невидимої динамічної підвіски. Ми робимо це, вибираючи спочатку видиму фігуру, потім, утримуючи клавішу Control, вибираючи її динамічний кулон, а потім [Menu bar --> Edit --> Make last selected object parent]. Такого ж результату можна досягти, перетягнувши видиму фігуру на її динамічний кулон в ієрархії сцени:

![image](https://user-images.githubusercontent.com/121936602/217025747-48b40edc-69e8-436a-b43f-0603e21fdaa6.png)

[Видимі форми, прикріплені до їхніх динамічних підвісок]

Нам все ще потрібно подбати про кілька речей: по-перше, оскільки ми хочемо, щоб динамічні форми були видимі лише для фізичного механізму, але не для інших модулів обчислень, ми знімаємо прапорці з усіх спеціальних властивостей об’єктів для динамічних форм у загальних [властивостях об’єктів](https://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#SceneHierarchy).

Потім нам все одно потрібно налаштувати динамічні фігури як динамічні та відповідні. Ми робимо це у [властивостях динаміки форми](https://www.coppeliarobotics.com/helpFiles/en/shapeDynamicsProperties.htm). Виберіть спочатку базову динамічну форму (тобто robot_dyn), а потім позначте пункт Body is respondable. Увімкніть перші 4 позначки локальної відповідної маски та вимкніть останні 4 прапорці локальної відповідної маски: важливо, щоб послідовні посилання, які відповідають, не стикалися одне з одним. Для першого мобільного динамічного посилання в нашому роботі (тобто robot_link_dyn1) ми також увімкнемо елемент Body is respondable, але цього разу ми вимкнемо перші 4 прапорці локальної відповідної маски та ввімкнемо останні 4 локальні позначки маски. Ми повторюємо описану вище процедуру з усіма іншими динамічними посиланнями, завжди чергуючи прапори локальної відповідної маски: коли модель буде визначена, послідовні динамічні форми робота не генеруватимуть жодної реакції на зіткнення під час взаємодії одна з одною. Намагайтеся завжди закінчувати конструкцією, у якій динамічна основа робота та динамічна остання ланка робота мають лише перші 4 прапорці локальної відповідної маски, щоб ми могли прикріпити робота до мобільної платформи або прикріпити захоплення до останньої динамічної ланки робота без динамічних перешкод зіткнення.

Нарешті, нам ще потрібно позначити наші динамічні форми як Body is dynamic. Ми робимо це також у [властивостях динаміки форми](https://www.coppeliarobotics.com/helpFiles/en/shapeDynamicsProperties.htm) .Потім ми можемо ввести властивості тензора маси та інерції вручну або автоматично обчислити ці значення (рекомендовано), натиснувши «Обчислити властивості маси та інерції» для вибраних опуклих форм. Пам'ятайте [також про те](https://www.coppeliarobotics.com/helpFiles/en/designingDynamicSimulations.htm#masses), [що стосується](https://www.coppeliarobotics.com/helpFiles/en/designingDynamicSimulations.htm#inertias) динамічного дизайну. Ця динамічна основа робота є особливим випадком: у більшості випадків ми хочемо, щоб основа робота (тобто robot_dyn) була нединамічною (тобто статичною), інакше, якщо використовувати її окремо, робот може впасти під час руху. Але як тільки ми прикріплюємо основу робота до мобільної платформи, ми хочемо, щоб основа стала динамічною (тобто не статичною). Ми робимо це, увімкнувши Set to dynamic if gets parent item, а потім вимкнувши Body is dynamic item. Тепер запустіть симуляцію: усі динамічні фігури, крім основи робота, повинні впасти. Приєднані візуальні форми будуть слідувати за своїми динамічними підвісками.

##Визначення моделі##

Тепер ми готові визначити нашу модель. Ми починаємо з побудови іерархії моделі: ми приєднуємо останнє динамічне посилання робота (robot_link_dyn6) до його відповідного з’єднання (robot_joint6), вибравши robot_link_dyn6, потім control-выбір robot_joint6, потім [Menu bar --> Edit --> Make last selected object parent]. Ми також могли б зробити цей крок, просто перетягнувши об’єкт robot_link_dyn6 на robot_link6 в [ієрархії сцени](https://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#SceneHierarchy). Ми продовжуємо, приєднуючи robot_joint6 до robot_link_dyn5 і так далі, поки не досягнемо основи робота. Тепер ми маємо таку ієрархію сцен:

![image](https://user-images.githubusercontent.com/121936602/217026305-4b832ea1-ba06-41cf-8e93-bb1203a49cf4.png)

[Ієрархія моделі робота]

Приємно і логічніше мати простий псевдонім для бази моделі, оскільки база моделі також представлятиме саму модель. Тож ми перейменуємо robot_dyn у robot. Тепер ми вибираємо основу дерева ієрархії (тобто об’єкт-робот) і в [загальних властивостях об’єкта](https://www.coppeliarobotics.com/helpFiles/en/commonPropertiesDialog.htm) ми вмикаємо Об’єкт є базою моделі. З'явилася модель обмежувальної рамки, що охоплює всього робота. Однак обмежувальна рамка видається завеликою: це тому, що обмежувальна рамка також охоплює невидимі елементи, наприклад суглоби. Тепер ми виключаємо з’єднання з обмежувальної рамки моделі, увімкнувши для всіх з’єднань пункт «Не показувати всередині моделі». Ми могли б виконати ту саму процедуру для всіх невидимих елементів у нашій моделі. Це також корисний параметр, щоб також виключити великі датчики або інші елементи з обмежувальної рамки моделі. Зараз маємо наступну ситуацію:

![image](https://user-images.githubusercontent.com/121936602/217026563-94e9073d-93cd-4d0a-9894-ac2505797b3f.png)

[Обмежувальна рамка моделі робота]

Тепер ми захищаємо нашу модель від випадкової зміни. Ми вибираємо всі видимі об’єкти в роботі, а потім натомість вмикаємо «Вибрати базу моделі»: якщо ми тепер клацнемо видиме посилання на сцені, замість неї буде вибрано основу робота. Це дозволяє нам маніпулювати моделлю так, ніби це єдиний об’єкт. Ми все ще можемо вибирати видимі об’єкти в роботі за допомогою клавіш Control-Shift-клацання на сцені або шляхом вибору об’єкта в ієрархії сцени. Тепер ми переводимо робота в правильне положення/орієнтацію за замовчуванням. По-перше, ми зберігаємо поточну сцену як еталон (наприклад, якщо на пізнішому етапі нам знадобиться імпортувати дані CAD, які мають таку ж орієнтацію на поточного робота). Потім ми вибираємо модель і відповідно [змінюємо її положення/орієнтацію](https://www.coppeliarobotics.com/helpFiles/en/coordinateDialog.htm). Хорошою практикою вважається розміщення моделі (тобто її базового об’єкта) на X=0 і Y=0.

![image](https://user-images.githubusercontent.com/121936602/217026716-5b6709c4-e8a7-42b8-ad13-5c06bbdaba9e.png)

[Модель робота в конфігурації за замовчуванням]

Тепер запускаємо симуляцію: робот згорнеться, оскільки суглоби не контролюються за замовчуванням. [Коли ми додали з’єднання на попередньому етапі](https://www.coppeliarobotics.com/helpFiles/en/buildingAModelTutorial.htm#joints), ми створили з’єднання в динамічному режимі, але зараз ними не керуємо. Тепер ми можемо налаштувати наші з’єднання відповідно до наших вимог, і в нашому випадку нам потрібен простий регулятор положення для кожного з них. У динамічних властивостях з’єднання ми вибираємо позицію як режим керування. Тепер ми запускаємо симуляцію знову: робот повинен утримувати своє положення. Спробуйте перемкнути поточний фізичний движок, щоб побачити, чи поведінка узгоджена для всіх підтримуваних фізичних движків. Це можна зробити за допомогою відповідної [кнопки на панелі інструментів](https://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#toolbars) або в [діалоговому вікні симуляції](https://www.coppeliarobotics.com/helpFiles/en/simulationPropertiesDialog.htm).

Під час симуляції ми тепер перевіряємо динамічний вміст сцени за допомогою [кнопки панелі інструментів візуалізації та перевірки динамічного вмісту](https://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#toolbars). Тепер відображатимуться лише елементи, які враховує фізичний движок, і дисплей буде [позначено кольором](https://www.coppeliarobotics.com/helpFiles/en/designingDynamicSimulations.htm#dynamicContentVisualization). Дуже важливо завжди робити це, особливо коли ваша динамічна модель не поводиться так, як очікувалося, щоб швидко налагодити модель. Так само завжди дивіться на ієрархію сцени під час симуляції: динамічно ввімкнені об’єкти мають відображати піктограму, що обмежує кулю, праворуч від їхнього псевдоніма.

![image](https://user-images.githubusercontent.com/121936602/217027001-4c61ee16-e8be-4809-826e-091e5a053bf6.png)

[Візуалізація та перевірка динамічного вмісту]

Нарешті, нам потрібно підготувати робота, щоб ми могли легко прикріпити до нього захват або легко прикріпити робота до мобільної платформи (наприклад). Дві динамічно активовані фігури можна жорстко приєднати одна до одної двома різними способами:
- згрупувавши їх: виберіть фігури, а потім [Menu bar --> Edit --> Grouping/Merging --> Group selected shapes].
- приєднавши їх за допомогою датчика сили/крутного моменту: [датчик сили і крутного моменту](https://www.coppeliarobotics.com/helpFiles/en/forceSensors.htm) також може діяти як жорстка ланка між двома окремими динамічно активованими формами.
У нашому випадку цікавить тільки 2 варіант. Ми створюємо датчик сили/крутного моменту за допомогою [Menu bar --> Add --> Force sensor], потім переміщуємо його на кінчик робота, а потім приєднуємо до об’єкта robot_link_dyn6. Ми відповідним чином змінюємо його розмір і візуальний вигляд (червоний датчик сили/крутного моменту часто сприймається як додаткова точка кріплення, перевірте різні доступні моделі роботів). Ми також змінюємо його псевдонім на robot_attachment: 

![image](https://user-images.githubusercontent.com/121936602/217027331-9ef77897-2384-401a-a2be-9a14ed7d07cc.png)

[Датчик сили кріплення/крутного моменту]

Тепер ми перетягуємо модель захвату в сцену, залишаємо її виділеною, потім клацаємо датчик сили прикріплення, утримуючи клавішу Control, а потім клацаємо кнопку на [панелі інструментів «Збірка/розбирання»](https://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#toolbars). Захват стає на місце:

![image](https://user-images.githubusercontent.com/121936602/217027574-f660a15e-750f-4efa-89b5-21d7027e4977.png)

[Прикріплений захват]

Захоплювач знав, як приєднатися, оскільки його було належним чином налаштовано під час визначення моделі. Тепер нам також потрібно належним чином налаштувати модель робота, щоб він знав, як приєднатися, наприклад, до мобільної бази. Вибираємо модель робота, а потім натискаємо Збірка в [загальних властивостях об’єкта](https://www.coppeliarobotics.com/helpFiles/en/commonPropertiesDialog.htm). Встановіть порожній рядок для значень відповідності «Батьківський» і натисніть «Установити матрицю». Це запам’ятає локальну матрицю перетворення поточного базового об’єкта та використає її для позиціонування/орієнтації відносно точки кріплення мобільного робота. Щоб переконатися, що ми зробили все правильно, ми перетягуємо модель Models/robots/mobile/KUKA Omnirob.ttm на сцену. Потім ми вибираємо нашу модель робота, потім клацаємо одну з точок кріплення на мобільній платформі, утримуючи клавішу Control, а потім натискаємо [кнопку на панелі інструментів «Збірка/розбирання»](https://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#toolbars). Наш робот повинен правильно розміститися на мобільному роботі:

![image](https://user-images.githubusercontent.com/121936602/217027753-4fe4088d-964c-4665-8f6c-fa419c4b74ee.png)

[Прикріплений робот]

Тепер ми можемо додати додаткові елементи до нашого робота, наприклад, датчики. У якийсь момент ми також можемо забажати приєднати [вбудовані сценарії](https://www.coppeliarobotics.com/helpFiles/en/scripts.htm) до нашої моделі, щоб контролювати її поведінку або налаштовувати її для різних цілей. У такому випадку переконайтеся, що ви розумієте, [як доступ до дескрипторів об’єктів здійснюється із вбудованих сценаріїв](https://www.coppeliarobotics.com/helpFiles/en/accessingSceneObjects.htm). Ми також можемо керувати/отримувати доступ/інтерфейс нашої моделі за допомогою [плагіна](https://www.coppeliarobotics.com/helpFiles/en/plugins.htm), з [віддаленого клієнта API](https://www.coppeliarobotics.com/helpFiles/en/remoteApiOverview.htm), з вузла [ROS](https://www.coppeliarobotics.com/helpFiles/en/rosInterfaces.htm) або з [аддонів](https://www.coppeliarobotics.com/helpFiles/en/addOns.htm).

Тепер ми переконаємося, що зміни, внесені під час приєднання робота та захвату, скасовано, згортаємо дерево ієрархії нашої моделі робота, вибираємо основу нашої моделі, а потім зберігаємо її за допомогою [Menu bar --> File --> Save model as...]. Якщо ми зберегли її в папці моделі, то модель буде доступна в [браузері моделей](https://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#ModelBrowser).
