# Посібник зі створення чистої моделі #
Цей навчальний посібник допоможе вам крок за кроком створити чисту імітаційну модель робота чи будь-якого іншого предмета. Це дуже важлива тема, можливо, найважливіший аспект, щоб мати приємну на вигляд, швидку відображення, швидку симуляцію та стабільну імітаційну модель.
Щоб проілюструвати процес створення моделі, ми створимо наступний маніпулятор:

![modelTut1](modelTut1.jpg)

[Модель робота-маніпулятора]

## Побудова видимих фігур ##
Створюючи нову модель, спочатку ми обробляємо лише її візуальний аспект: динамічний аспект (його ще більш спрощена/оптимізована модель), з’єднання, датчики тощо буде розглянуто пізніше.

Тепер ми могли безпосередньо створювати примітивні форми в CoppeliaSim за допомогою [Рядок меню --> Додати --> Примітивна форма --> ...]. Роблячи це, ми маємо можливість створювати примітивні форми, або правильні форми. Примітивні фігури будуть оптимізовані для динамічної взаємодії, а також будуть безпосередньо активовані динамічно (тобто падіння, зіткнення, але це можна вимкнути на пізнішому етапі). Примітивні форми будуть простими сітками, які можуть містити недостатньо деталей або геометричної точності для нашого застосування. Іншим нашим варіантом у такому випадку буде імпорт сітки із зовнішньої програми.

Під час імпорту даних САПР із зовнішньої програми найважливішим є переконатися, що модель САПР не надто важка, тобто не містить занадто багато трикутників. Ця вимога важлива, оскільки важка модель буде повільно відображатися, а також уповільнити роботу різних модулів обчислень, які можуть бути використані на пізнішому етапі (наприклад, обчислення мінімальної відстані або динаміки). Наступний приклад зазвичай не підходить (навіть якщо, як ми побачимо пізніше, є засоби для спрощення даних у CoppeliaSim):

![modelTut2](modelTut2.jpg)

[Складні дані САПР (у твердому та каркасному)]

Наведені вище дані CAD дуже важкі: вони містять багато трикутників (понад 47 000), що було б добре, якби ми використали лише один екземпляр у порожній сцені. Але здебільшого вам захочеться змоделювати кілька екземплярів одного робота, прикріпити різні типи захватів і, можливо, запропонувати цим роботам взаємодіяти з іншими роботами, пристроями чи середовищем. У такому випадку сцена симуляції може швидко стати надто повільною. Як правило, ми рекомендуємо моделювати робота з не більше ніж 20 000 трикутниками, але в більшості випадків 5 000-10 000 трикутників також підійдуть. Пам’ятайте: менше – краще майже в усіх аспектах.
Що робить цю модель такою важкою? По-перше, моделі, які містять отвори та дрібні деталі, потребуватимуть набагато більше трикутних граней для правильного зображення. Тому, якщо це можливо, спробуйте видалити всі отвори, гвинти, внутрішню частину об’єктів тощо з вихідних даних моделі. Якщо у вас є вихідні дані моделі, представлені у вигляді параметричних поверхонь/об’єктів, у більшості випадків досить просто вибрати елементи та видалити їх (наприклад, у Solidworks). Другим важливим кроком є експорт вихідних даних з обмеженою точністю: більшість програм САПР дозволяють вказати рівень деталей експортованих сіток. Також може бути важливо експортувати об’єкти в кілька кроків, коли малюнок складається з великих і малих об’єктів; це робиться для того, щоб уникнути надто точного визначення великих об’єктів (забагато трикутників) і надто грубого визначення малих об’єктів (замало трикутників): просто спочатку експортуйте великі об’єкти (налаштувавши потрібні параметри точності), а потім малі об’єкти (налаштувавши налаштування точності) ).

Тепер припустимо, що ми застосували всі можливі спрощення, як описано в попередньому розділі. Ми все ще можемо отримати занадто важку сітку після імпорту:

![modelTut3](modelTut3.jpg)

[Імпортовані дані CAD]

Ви можете помітити, що весь робот був імпортований як одна сітка. Пізніше ми побачимо, як це правильно розділити. Зверніть також увагу на неправильну орієнтацію імпортованої сітки: найкраще залишити орієнтацію такою, як вона є, доки не буде побудовано всю модель, оскільки, якщо на пізнішому етапі ми захочемо імпортувати інші елементи, пов’язані з тим самим роботом, вони будуть автоматично маюти правильне положення/орієнтацію відносно вихідної сітки.
На цьому етапі ми маємо в своєму розпорядженні кілька функцій для спрощення сітки:

- Автоматичне поділ сітки: дозволяє генерувати нову форму для всіх елементів, які не з’єднані між собою спільним краєм. Це не завжди працює для вибраної сітки, але завжди варто спробувати, оскільки робота над елементами сітки дає нам більше контролю, ніж якби ми мали працювати над усіма елементами одночасно. Доступ до цієї функції можна отримати за допомогою [Menu bar --> Edit --> Grouping/Merging --> Divide selected shapes]. Іноді сітка буде розділена більше, ніж очікувалося. У такому випадку просто об’єднайте елементи, які логічно належать разом (тобто матимуть однакові візуальні атрибути та є частиною одного посилання), назад в одну форму ([Menu bar --> Edit -> Grouping/Merging --> Merge selected shapes]).

- Вилучити опуклу оболонку: дозволяє спростити сітку, перетворивши її на опуклу оболонку. Доступ до цієї функції можна отримати за допомогою [Menu bar --> Edit --> Morph selection into convex shapes].

- Знищити сітку: дозволяє зменшити кількість трикутників у сітці. Доступ до цієї функції можна отримати за допомогою [Menu bar --> Edit --> Decimate selected shape...].
Немає заздалегідь визначеного порядку, у якому вищезгадані функції можуть/потрібно застосовуватися (за винятком першого елемента у списку, який завжди слід пробувати першим), це сильно залежить від геометрії сітки, яку ми намагаємося спростити. Наступне зображення ілюструє наведені вище функції, застосовані до імпортованої сітки (припустімо, що перший елемент у списку не спрацював для нас):

![image](image.png)

[Опукла оболонка та розрізана сітка]

Зверніть увагу, що опукла оболонка не допомагає нам на цьому етапі. Ми вирішуємо спочатку використати функцію децимації сітки, а потім запускаємо функцію двічі, щоб розділити кількість трикутників на загальну суму 50. У підсумку ми отримуємо сітку, яка містить 2660 трикутників (оригінальна імпортована сітка містила понад 136 000 трикутників!). Кількість трикутників/вершин фігури можна побачити в діалоговому вікні геометрії фігури. 2660 трикутників — це надзвичайно мало трикутників для цілої моделі робота, і від цього візуальний вигляд може трохи постраждати.
На цьому етапі ми можемо почати розділяти робота на окремі ланки (пам’ятайте, що зараз у нас є лише одна форма для всього робота). Це можна зробити двома способами:
- Автоматичне поділ сітки: ця функція, яка вже була описана в попередньому розділі, перевірить форму та створить нову форму для всіх елементів, які не з’єднані між собою спільним краєм. Це не завжди працює, але завжди варто спробувати. Доступ до цієї функції можна отримати за допомогою [Рядок меню --> Редагувати --> Групування/об’єднання --> Розділити вибрані фігури].
- Поділ сітки вручну: за допомогою режиму редагування трикутника ви можете вручну вибрати трикутники, які логічно належать разом, а потім натиснути «Витягнути форму». Це створить нову форму сцени. Видаліть вибрані трикутники після цієї операції.

У випадку нашої сітки метод 1 спрацював нормально:

![modelTut5](modelTut5.jpg)

[Розділена сітка]

Тепер ми можемо ще більше вдосконалити/спростити окремі форми. Іноді також форма може виглядати краще, якщо замість неї використовувати її опуклу оболонку. В інших випадках, щоб отримати бажаний результат, вам доведеться повторно використовувати кілька описаних вище прийомів. Візьмемо, наприклад, наступну сітку:

![modelTut6](modelTut6.jpg)

[Імпортована сітка]

Проблема з наведеною вище формою полягає в тому, що ми не можемо її красиво спростити через отвори, які вона містить. Тож нам доведеться піти складнішим шляхом через режим редагування форми, де ми можемо витягувати окремі елементи, які логічно належать до тієї самої опуклої суб-сутності. Цей процес може тривати кілька ітерацій: спочатку ми виділяємо 3 приблизних опуклих елемента. Наразі ми ігноруємо трикутники, які є частиною двох отворів. Під час редагування форми в режимі редагування форми може бути зручно перемикати шари видимості, щоб побачити, що закрито іншими елементами сцени.

![modelTut7](modelTut7.jpg)

[Крок 1]

У підсумку ми маємо інструмент із трьох форм, але дві з них потребують подальшого вдосконалення. Тепер ми можемо стерти трикутники, які є частиною отворів. Нарешті, ми витягуємо опуклу оболонку окремо для 3 фігур, а потім об’єднуємо їх разом за допомогою [Menu bar --> Edit --> Grouping/Merging --> merge selected shapes]:![modelTut8](https://user-images.githubusercontent.com/121936602/217019549-72987bd1-8db5-4fb9-841b-d5fd67e862ba.jpg)

[Крок 2]

У CoppeliaSim ми можемо вказати кут затінення, який визначає, наскільки фасетками буде відображатися форма. Цей параметр і деякі інші, наприклад колір форми, можна налаштувати у властивостях форми. Пам’ятайте, що форми бувають різних смаків. У цьому підручнику ми досі мали справу лише з простими фігурами: проста фігура має один набір візуальних атрибутів (тобто один колір, один кут затінення тощо). Якщо об’єднати дві фігури, результатом буде проста фігура. Ви також можете групувати фігури, у цьому випадку кожна фігура збереже свої візуальні атрибути.

На наступному кроці ми можемо об’єднати елементи, які логічно належать один одному (якщо вони є частиною одного жорсткого елемента та мають однакові візуальні атрибути). Потім ми змінюємо візуальні атрибути різних елементів. Найпростіше налаштувати кілька фігур, які мають різні кольори та візуальні атрибути, і якщо ми називаємо колір певним рядком, ми можемо пізніше легко програмно змінити цей колір, навіть якщо фігура є частиною складеної фігури. Потім ми вибираємо всі фігури з однаковими візуальними атрибутами, потім вибираємо форму, яка вже була скоригована, і натискаємо «Застосувати до виділення» один раз для кольорів, один раз для інших властивостей у властивостях фігури: це переносить усі візуальні атрибути вибраних форм (включаючи назву кольору, якщо ви її вказали). У підсумку ми маємо 17 окремих форм:

![image](https://user-images.githubusercontent.com/121936602/217020242-ddc15f01-625d-4833-907a-dc0b27e253a9.png)

[Скориговані візуальні атрибути]

Тепер ми можемо групувати фігури, які є частиною одного посилання, за допомогою [Menu bar --> Edit --> Grouping/merging -> Group selected shapes]. У підсумку ми маємо 7 фігур: основу робота (або основу ієрархічного дерева робота) і 6 мобільних посилань. Також важливо правильно називати об’єкти: ви робите це подвійним клацанням на псевдонімі об’єкта в ієрархії сцени. За замовчуванням фігури буде призначено шару видимості 1, але їх можна змінити в загальних властивостях об’єкта. За замовчуванням для сцени активовано лише шари видимості 1-8. Зараз ми маємо наступне:

![image](https://user-images.githubusercontent.com/121936602/217020689-6ccdd70c-7a8e-4008-8682-ccba587c953c.png)

[Окремі елементи складають робота]

Коли фігура створюється або змінюється, CoppeliaSim автоматично встановлює положення та орієнтацію опорної рамки. Рамка відліку фігури завжди буде розташована в геометричному центрі фігури. Орієнтація рамки буде вибрана так, щоб обмежувальна рамка фігури залишалася якомога меншою. Це не завжди виглядає красиво, але ми завжди можемо змінити орієнтацію системи відліку форми в будь-який час. Тепер ми змінюємо орієнтацію систем відліку всіх наших створених форм за допомогою [Menu bar --> Edit --> Reorient bounding box --> with reference frame of world]. У діалоговому вікні геометрії фігури є більше можливостей для зміни орієнтації опорної рамки.

## Нарощування стиків ##

Тепер ми подбаємо про стикі/мотори. У більшості випадків ми знаємо точне положення та орієнтацію кожного з стику. У такому випадку ми просто додаємо з’єднання за допомогою [Menu bar --> Add --> Joints --> ...], а потім ми можемо змінити їхнє положення та орієнтацію за допомогою діалогового вікна розташування та орієнтації. В інших ситуаціях ми маємо лише параметри Денавіта-Хартенберга (тобто D-H). У такому випадку ми можемо побудувати наші з’єднання за допомогою моделі інструменту, розташованої в Models/tools/Denavit-Hartenberg joint creator.ttm у браузері моделей. В інших випадках ми не маємо інформації про розташування та орієнтацію спільних частин. Потім нам потрібно витягти їх з імпортованої сітки. Припустимо, це наш випадок. Замість того, щоб працювати над зміненою, більш наближеною сіткою, ми відкриваємо нову сцену та знову імпортуємо оригінальні дані CAD. У більшості випадків ми можемо витягти сітки або примітивні форми з оригінальної сітки. Перший крок — розділити оригінальну сітку. Якщо це не працює, ми робимо це через режим редагування трикутника. Припустімо, що ми можемо розділити оригінальну сітку. Зараз у нас є менші об’єкти, які ми можемо оглянути. Ми шукаємо обертові форми, які можна було б використовувати як еталон для створення з’єднань у їхніх місцях з однаковою орієнтацією. Спочатку приберіть усі непотрібні предмети. Іноді також корисно працювати з декількома відкритими сценами для легшої візуалізації/маніпуляції. У нашому випадку ми спершу зосереджуємося на основі робота: вона містить циліндр, який має правильне положення для першого стика. У режимі редагування трикутника ми маємо:
 
![image](https://user-images.githubusercontent.com/121936602/217021798-d9c7ad50-d95f-4e55-a5a1-6e4f3b592efc.png)

[База робота: візуалізація нормального та трикутного режимів редагування]

Змінюємо вид камери за допомогою кнопки панелі інструментів вибору сторінок, щоб дивитися на об’єкт збоку. Кнопка на панелі інструментів, яка підходить для перегляду, може стати в нагоді, щоб правильно обрамити об’єкт у редакції. Потім переходимо в режим редагування вершин і виділяємо всі вершини, які належать верхньому диску. Пам’ятайте, що вмикаючи/вимикаючи деякі шари, ми можемо приховати інші об’єкти на сцені. Потім повертаємося в режим редагування трикутника:

![image](https://user-images.githubusercontent.com/121936602/217022003-1ae746f6-5893-4442-95d1-9e067db688ba.png)

[Вибраний верхній диск, режим редагування вершин (1 і 2), режим редагування трикутника (3)]

Тепер ми клацаємо «Extract cylinder» (у цьому випадку також буде працювати), це створило форму циліндра на сцені на основі вибраних трикутників. Виходимо з режиму редагування і скидаємо зміни. Тепер ми додаємо поворотне з’єднання за допомогою [Menu bar --> Add --> Joint --> Revolute], залишаємо його вибраним, а потім натискаємо клавішу Control і вибираємо вилучену форму циліндра. У діалоговому вікні «Позиція» на вкладці «Позиція» ми клацаємо «Застосувати до вибору»: це фактично копіює положення циліндра x/y/z на з’єднання. Тепер обидві позиції ідентичні. У діалоговому вікні орієнтації на вкладці орієнтації ми також натискаємо «Застосувати до виділення»: орієнтація вибраних об’єктів тепер також однакова. Іноді нам потрібно буде додатково повернути стика приблизно на 90/180 градусів навколо його власної системи відліку, щоб отримати правильну орієнтацію або напрямок обертання. За потреби ми можемо зробити це на вкладці обертання цього діалогового вікна (у такому випадку не забудьте натиснути кнопку «Власний кадр»). Подібним чином ми могли б також зміщувати стик уздовж його осі або навіть робити більш складні операції. Ось що ми маємо:

![image](https://user-images.githubusercontent.com/121936602/217022723-9b146919-6b17-4af6-ae8e-6f8c0d3f7d69.png)

[З’єднання в правильному місці, з правильною орієнтацією]

Тепер ми копіюємо з’єднання назад у нашу оригінальну сцену та зберігаємо його (не забувайте регулярно зберігати свою роботу! Функція скасування/повторення корисна, але не захищає вас від інших невдач). Ми повторюємо описану вище процедуру для всіх стикків нашого робота, а потім перейменуємо їх. Ми також робимо всі з’єднання трохи довшими у властивостях з’єднань, щоб побачити їх усі. За замовчуванням з’єднання буде призначено шару видимості 2, але їх можна змінити в загальних властивостях об’єкта. Тепер ми призначаємо всі з’єднання шару видимості 10, а потім тимчасово вмикаємо шар видимості 10 для сцени, щоб також візуалізувати ці з’єднання (за замовчуванням для сцени активовано лише шари видимості 1-8). Ось що ми маємо:

![image](https://user-images.githubusercontent.com/121936602/217022947-3470164b-1865-4f73-afd3-b061a7c8da0c.png)

[Стики в правильній конфігурації]

На цьому етапі ми можемо почати будувати ієрархію моделі та завершити визначення моделі. Але якщо ми хочемо, щоб наш робот був динамічно ввімкнений, то є додатковий проміжний крок:

