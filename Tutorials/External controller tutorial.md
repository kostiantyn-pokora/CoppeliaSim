# Підручник зовнішнього контролера #
У CoppeliaSim є кілька способів керування роботом або моделюванням:
- Найзручніший спосіб — написати дочірній скрипт (на Lua або Python), який оброблятиме поведінку даного робота чи моделі. Це найзручніший спосіб, оскільки дочірні сценарії безпосередньо приєднані до об’єктів сцени, вони будуть продубльовані разом із пов’язаними об’єктами сцени, їм не потрібна будь-яка компіляція за допомогою зовнішнього інструменту, вони можуть працювати в потоковому або непотоковому режимі, їх можна розширити за допомогою спеціальних функцій скриптів або за допомогою механізмів розширення мови Lua/Python. Ще одна головна перевага використання дочірніх сценаріїв: немає затримки зв’язку, як у випадку з останніми 3 методами, згаданими в цьому розділі (тобто використовується звичайний API), а дочірні сценарії є частиною основного потоку програми (внутрішня синхронна робота). Однак між Lua та Python є невеликі відмінності.
- Ще один спосіб керування роботом або симуляцією — це написання плагіна. Механізм плагіна дозволяє використовувати механізми зворотного виклику, реєстрацію функцій спеціального сценарію та, звичайно, доступ до зовнішніх бібліотек функцій. Плагін часто використовується в поєднанні з дочірніми сценаріями (наприклад, плагін реєструє власні функції сценарію, які, викликані з дочірнього сценарію, викличуть певну функцію плагіна). Основною перевагою використання плагінів також є відсутність затримки зв’язку, як у випадку з останніми 3 методами, згаданими в цьому розділі (тобто використовується звичайний API), і те, що плагін є частиною основного потоку програми (внутрішня синхронна робота).Недоліки плагінів такі: їх складніше програмувати, і їх також потрібно скомпілювати за допомогою зовнішнього. Зверніться також до посібника з плагіна.
- Третій спосіб керування роботом або симуляцією — це написання зовнішньої клієнтської програми, яка покладається на віддалений API. Це дуже зручний і простий спосіб, якщо вам потрібно запустити керуючий код із зовнішньої програми, з робота або з іншого комп'ютера. Це також дозволяє керувати симуляцією або моделлю (наприклад, віртуальним роботом) за допомогою точно такого ж коду, який запускає реальний робот.
- Четвертий спосіб керування роботом або симуляцією — через вузол ROS. Подібно до віддаленого API, ROS є зручним способом спілкування кількох розподілених процесів один з одним. Хоча віддалений API дуже легкий і швидкий, він дозволяє спілкуватися лише з CoppeliaSim. З іншого боку, ROS дозволяє з’єднувати практично будь-яку кількість процесів один з одним, і доступна велика кількість сумісних бібліотек. Однак він важчий і складніший, ніж віддалений API. Зверніться до інтерфейсів ROS для отримання додаткової інформації.
- П’ятий спосіб керування роботом або симуляцією — це написання зовнішньої програми, яка взаємодіє через різні засоби (наприклад, канали, ZeroMQ, сокети, послідовний порт тощо) із плагіном CoppeliaSim або сценарієм CoppeliaSim. Двома основними перевагами є можливість вибору мови програмування, яка може бути будь-якою мовою, і гнучкість. Тут також код керування може працювати на роботі або іншому комп’ютері. Однак цей спосіб керування симуляцією чи моделлю є більш виснажливим, ніж методи з віддаленим API.

Є 7 файлів сцен, пов’язаних із цим посібником:
- scenes/controlTypeExamples/controlledViaScript: трьома роботами керують відповідні дочірні сценарії: один виконує потоковий код Lua, один запускає безпотоковий код Lua, а останній запускає безпотоковий код Python.
- scenes/controlTypeExamples/controlledViaPlugin: роботом керується за допомогою плагіна.
- scenes/controlTypeExamples/controlledViaRemoteApi: роботом керують через зовнішню програму та віддалений API ZeroMQ.
- scenes/controlTypeExamples/controlledViaRos: роботом керують через зовнішню програму та інтерфейс ROS.
- scenes/controlTypeExamples/controlledViaRos2: роботом керують через зовнішню програму та інтерфейс ROS 2.
- scenes/controlTypeExamples/controlledViaZmq: роботом керують через зовнішню програму та ZeroMQ.
- scenes/controlTypeExamples/controlledViaTcp: роботом керують через зовнішню програму та LuaSocket і TCP.

![image](https://user-images.githubusercontent.com/121936602/217079352-f15ec395-c2d8-4c22-bd3d-be69ac34d6e1.png)

У всіх 7 випадках використовуються дочірні сценарії, головним чином для встановлення зв’язку із зовнішнім світом (наприклад, запуск правильної клієнтської програми та передача їй правильних дескрипторів об’єктів). Є ще два способи керування роботом, моделюванням або самим симулятором: за допомогою сценаріїв налаштування або доповнень. Однак їх не рекомендується використовувати для керування, а краще використовувати для обробки функціональності, коли симуляція не запущена.

Як приклад, дочірній сценарій, пов’язаний із роботом у сцені controlledViaRos.ttt, має такі основні завдання:
- Перевірте, чи завантажено інтерфейс ROS/інтерфейс ROS 2 для CoppeliaSim
- Запустіть програму контролера (rosBubbleRob / ros2BubbleRob) з деякими назвами тем або описами об’єктів як аргументами

Як інший приклад, дочірній сценарій, пов’язаний з роботом у сцені controlledViaZmq.ttt, має такі основні завдання:
- Знайдіть вільний порт підключення сокета
- Запустіть програму контролера (bubbleRobZmqServer) з вибраним портом підключення як аргументом
- Локальне підключення до програми контролера
- Під час кожного проходу моделювання надсилайте значення датчиків до контролера та зчитуйте бажані значення двигуна з контролера
- Під час кожного проходу симуляції застосовуйте бажані значення двигуна до суглобів робота

Запустіть симуляції, скопіюйте та вставте робота: ви побачите, що дубльовані роботи будуть працювати безпосередньо, оскільки їхні підключені дочірні сценарії відповідають за запуск нових екземплярів відповідних зовнішніх програм або виклик відповідних функцій плагіна.


