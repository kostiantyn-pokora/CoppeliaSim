# Підручник зовнішнього контролера #
У CoppeliaSim є кілька способів керування роботом або моделюванням:

- Найзручніший спосіб — написати [дочірній скрипт](https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm) (на Lua або Python), який оброблятиме поведінку даного робота чи [моделі](https://www.coppeliarobotics.com/helpFiles/en/models.htm). Це найзручніший спосіб, оскільки дочірні сценарії безпосередньо приєднані до [об’єктів сцени](https://www.coppeliarobotics.com/helpFiles/en/objects.htm), вони будуть продубльовані разом із пов’язаними об’єктами сцени, їм не потрібна будь-яка компіляція за допомогою зовнішнього інструменту, вони можуть працювати в [потоковому або непотоковому режимі](https://www.coppeliarobotics.com/helpFiles/en/threadedAndNonThreadedCode.htm), їх можна розширити за допомогою [спеціальних функцій скриптів](https://www.coppeliarobotics.com/helpFiles/en/apiFunctions.htm#customizingLuaFunctions) або за допомогою механізмів розширення мови Lua/Python. Ще одна головна перевага використання дочірніх сценаріїв: немає затримки зв’язку, як у випадку з останніми 3 методами, згаданими в цьому розділі (тобто використовується [звичайний API](https://www.coppeliarobotics.com/helpFiles/en/apiFunctions.htm)), а дочірні сценарії є частиною основного потоку програми (внутрішня синхронна робота). Однак між [Lua та Python є невеликі відмінності](https://www.coppeliarobotics.com/helpFiles/en/luaPythonDifferences.htm).

- Ще один спосіб керування роботом або симуляцією — це написання [плагіна](https://www.coppeliarobotics.com/helpFiles/en/plugins.htm). Механізм плагіна дозволяє використовувати механізми зворотного виклику, [реєстрацію функцій спеціального сценарію](https://www.coppeliarobotics.com/helpFiles/en/apiFunctions.htm#customizingLuaFunctions) та, звичайно, доступ до зовнішніх бібліотек функцій. Плагін часто використовується в поєднанні з дочірніми сценаріями (наприклад, плагін реєструє власні функції сценарію, які, викликані з дочірнього сценарію, викличуть певну функцію плагіна). Основною перевагою використання плагінів також є відсутність затримки зв’язку, як у випадку з останніми 3 методами, згаданими в цьому розділі (тобто використовується [звичайний API](https://www.coppeliarobotics.com/helpFiles/en/apiFunctions.htm)), і те, що плагін є частиною основного потоку програми (внутрішня синхронна робота).Недоліки плагінів такі: їх складніше програмувати, і їх також потрібно скомпілювати за допомогою зовнішнього. Зверніться також до [посібника з плагіна](https://www.coppeliarobotics.com/helpFiles/en/pluginTutorial.htm).

- Третій спосіб керування роботом або симуляцією — це написання зовнішньої клієнтської програми, яка покладається на [віддалений API](https://www.coppeliarobotics.com/helpFiles/en/remoteApiOverview.htm). Це дуже зручний і простий спосіб, якщо вам потрібно запустити керуючий код із зовнішньої програми, з робота або з іншого комп'ютера. Це також дозволяє керувати симуляцією або [моделлю](https://www.coppeliarobotics.com/helpFiles/en/models.htm) (наприклад, віртуальним роботом) за допомогою точно такого ж коду, який запускає реальний робот.

- Четвертий спосіб керування роботом або симуляцією — через вузол [ROS](http://www.ros.org/). Подібно до [віддаленого API](https://www.coppeliarobotics.com/helpFiles/en/remoteApiOverview.htm), ROS є зручним способом спілкування кількох розподілених процесів один з одним. Хоча віддалений API дуже легкий і швидкий, він дозволяє спілкуватися лише з CoppeliaSim. З іншого боку, ROS дозволяє з’єднувати практично будь-яку кількість процесів один з одним, і доступна велика кількість сумісних бібліотек. Однак він важчий і складніший, ніж віддалений API. Зверніться до [інтерфейсів ROS](https://www.coppeliarobotics.com/helpFiles/en/rosInterfaces.htm) для отримання додаткової інформації.

- П’ятий спосіб керування роботом або симуляцією — це написання зовнішньої програми, яка взаємодіє через різні засоби (наприклад, канали, [ZeroMQ](https://www.coppeliarobotics.com/helpFiles/en/meansOfCommunication.htm#zmq), [сокети](https://www.coppeliarobotics.com/helpFiles/en/meansOfCommunication.htm#sockets), [послідовний порт](https://www.coppeliarobotics.com/helpFiles/en/meansOfCommunication.htm#serialPort) тощо) із плагіном CoppeliaSim або сценарієм CoppeliaSim. Двома основними перевагами є можливість вибору мови програмування, яка може бути будь-якою мовою, і гнучкість. Тут також код керування може працювати на роботі або іншому комп’ютері. Однак цей спосіб керування симуляцією чи моделлю є більш виснажливим, ніж методи з [віддаленим API](https://www.coppeliarobotics.com/helpFiles/en/remoteApiOverview.htm).

Є 7 файлів сцен, пов’язаних із цим посібником:
- scenes/controlTypeExamples/controlledViaScript: трьома роботами керують відповідні [дочірні сценарії](https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm): один виконує потоковий код Lua, один запускає безпотоковий код Lua, а останній запускає безпотоковий код Python.
- scenes/controlTypeExamples/controlledViaPlugin: роботом керується за допомогою [плагіна](https://www.coppeliarobotics.com/helpFiles/en/plugins.htm).
- scenes/controlTypeExamples/controlledViaRemoteApi: роботом керують через [зовнішню програму](https://github.com/CoppeliaRobotics/bubbleRobClient) та [віддалений API ZeroMQ](https://www.coppeliarobotics.com/helpFiles/en/zmqRemoteApiOverview.htm).
- scenes/controlTypeExamples/controlledViaRos: роботом керують через [зовнішню програму](https://github.com/CoppeliaRobotics/bubbleRobClient) та [інтерфейс ROS](https://www.coppeliarobotics.com/helpFiles/en/rosInterf.htm).
- scenes/controlTypeExamples/controlledViaRos2: роботом керують через [зовнішню програму](https://github.com/CoppeliaRobotics/bubbleRobClient) та [інтерфейс ROS 2](https://www.coppeliarobotics.com/helpFiles/en/ros2Interface.htm).
- scenes/controlTypeExamples/controlledViaZmq: роботом керують через [зовнішню програму](https://github.com/CoppeliaRobotics/bubbleRobClient) та [ZeroMQ](https://zeromq.org/).
- scenes/controlTypeExamples/controlledViaTcp: роботом керують через [зовнішню програму](https://github.com/CoppeliaRobotics/bubbleRobClient) та [LuaSocket](http://w3.impa.br/~diego/software/luasocket/) і TCP.

![image](https://user-images.githubusercontent.com/121936602/217079352-f15ec395-c2d8-4c22-bd3d-be69ac34d6e1.png)

У всіх 7 випадках використовуються [дочірні сценарії](https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm0), головним чином для встановлення зв’язку із зовнішнім світом (наприклад, запуск правильної клієнтської програми та передача їй правильних дескрипторів об’єктів). Є ще два способи керування роботом, моделюванням або самим симулятором: за допомогою [сценаріїв налаштування](https://www.coppeliarobotics.com/helpFiles/en/customizationScripts.htm) або [доповнень](https://www.coppeliarobotics.com/helpFiles/en/addOns.htm). Однак їх не рекомендується використовувати для керування, а краще використовувати для обробки функціональності, коли симуляція не запущена.

Як приклад, дочірній сценарій, пов’язаний із роботом у сцені controlledViaRos.ttt, має такі основні завдання:
- Перевірте, чи завантажено [інтерфейс ROS](https://www.coppeliarobotics.com/helpFiles/en/rosInterf.htm)/[інтерфейс ROS 2](https://www.coppeliarobotics.com/helpFiles/en/ros2Interface.htm). для CoppeliaSim
- Запустіть програму контролера ([rosBubbleRob](https://github.com/CoppeliaRobotics/ros_bubble_rob)/ [ros2BubbleRob](https://github.com/CoppeliaRobotics/ros2_bubble_rob)) з деякими назвами тем або описами об’єктів як аргументами

Як інший приклад, дочірній сценарій, пов’язаний з роботом у сцені controlledViaZmq.ttt, має такі основні завдання:
- Знайдіть вільний порт підключення сокета
- Запустіть програму контролера ([bubbleRobZmqServer](https://github.com/CoppeliaRobotics/bubbleRobZmqServer)) з вибраним портом підключення як аргументом
- Локальне підключення до програми контролера
- Під час кожного проходу моделювання надсилайте значення датчиків до контролера та зчитуйте бажані значення двигуна з контролера
- Під час кожного проходу симуляції застосовуйте бажані значення двигуна до суглобів робота

Запустіть симуляції, скопіюйте та вставте робота: ви побачите, що дубльовані роботи будуть працювати безпосередньо, оскільки їхні підключені дочірні сценарії відповідають за запуск нових екземплярів відповідних зовнішніх програм або виклик відповідних функцій плагіна.


